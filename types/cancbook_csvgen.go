package types

import (
	// "fmt"
	errors "github.com/pkg/errors"
	strconv "strconv"
)

// This code is generated by 'csvgen'
// Do not edit

// UnmarshalCSV CancBookV1 func
func (pv *CancBookV1) UnmarshalCSV(in []string) error {
	if in == nil || len(in) < 14 {
		return errors.New("Invalid input to *CancBookV1 UnmarshalCSV")
	}
	// fmt.Println(in)
	i := 0
	if in[i] == "" {
		pv.Pp = 0
	} else {
		umPp, err := strconv.ParseInt(in[i], 10, 0)
		if err != nil {
			return err
		}
		pv.Pp = int(umPp)
	}
	i++
	if in[i] == "" {
		pv.Number = 0
	} else {
		umNumber, err := strconv.ParseInt(in[i], 10, 0)
		if err != nil {
			return err
		}
		pv.Number = int(umNumber)
	}
	i++
	if err := pv.Init.UnmarshalCSV(in[i]); err != nil {
		return err
	}
	i++
	pv.Fact = in[i]
	i++
	if err := pv.Victim.UnmarshalCSV(in[i]); err != nil {
		return err
	}
	i++
	if err := pv.MinorVictim.UnmarshalCSV(in[i]); err != nil {
		return err
	}
	i++
	if err := pv.Damage.UnmarshalCSV(in[i]); err != nil {
		return err
	}
	i++
	if err := pv.Accused.UnmarshalCSV(in[i]); err != nil {
		return err
	}
	i++
	pv.Qualification = in[i]
	i++
	pv.ArrestDate = in[i]
	i++
	pv.Evidence = in[i]
	i++
	if err := pv.Conditions.UnmarshalCSV(in[i]); err != nil {
		return err
	}
	i++
	if err := pv.MinorAccused.UnmarshalCSV(in[i]); err != nil {
		return err
	}
	i++
	pv.Detention = in[i]
	return nil
}

// CancBookV1List csvparse.Pusher implementation
type CancBookV1List []CancBookV1

// Push function for CancBookV1List struct
func (pl *CancBookV1List) Push(in []string) error {
	nf := CancBookV1{}
	if err := nf.UnmarshalCSV(in); err != nil {
		return errors.Wrapf(err, "Error in UnmarshalCSV CancBookV1 in line %#v ", in)
	}
	*pl = append(*pl, nf)
	return nil
}
